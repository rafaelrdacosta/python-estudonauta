Módulo 3 - Estruturas Compostas

Tuplas -> ()
Listas -> []
Dicionários -> {}

1) Tuplas()
    - É um quantidade de valores separados por vírgula.
    - Elas podem ser com ou sem parênteses, embora frenquentemente os parênteses sejam necessários.
    - Não é possível atribuir valores a itens individuais.
    - Tuplas são IMUTÁVEIS e normalmente contêm uma sequência HETEROGÊNEA de itens, que são acessados
por seus índices.
    - O índice começa em zero

    empty = () ->tupla vazia
    lanche = 'sanduiche', 'suco', 'pizza', 'pudim'

    print(lanche)                                           #saída: ('sanduiche', 'suco', 'pizza', 'pudim')
    print(sorted(lanche))                                   #saída: ['pizza', 'pudim', 'sanduiche', 'suco']
    print(lanche[2]) -> pizza
    print(lanche[0:2]) -> ('sanduiche', 'suco')             #vai excluir o último elemento
    print(lanche[1:]) -> ('suco', 'pizza', 'pudim')
    print(lanche[:2]) -> ('sanduiche', 'suco')              #vai excluir o último elemento
    print(lanche[-1]) -> pudim                              #a contagem será do fim para o início
    print(len(lanche)) -> 4                                 #retorna a quantidade de elementos da tupla

    for c in lanche:                                        #será criado uma variável simples c que a cada iteração receberá o valor do item
        print(c)                                            #saída será: sanduiche\n suco\n pizza\n pudim

    for cont in range (0, len(lanche)):
        print(lanche[cont])                                 #saída será: sanduiche\n suco\n pizza\n pudim

    for pos, comida in enumerate(lanche):
        print(f'Eu vou comer {comida} na posição {pos}')    #saída 1ª iteração: Eu vou comer sanduiche na posição 0

    a = (2, 5, 4)
    b = (5, 8, 1, 2)
    c = a + b                                               #serão concatenadas as duas tuplas
    print(c)                                                #saída: (2, 5, 4, 5, 8, 1, 2)

    Método count - irá contar a ocorrência do parâmetro passado na tupla
        print(c.count(5))                                       #saída será 2

    Método index - irá retornar o índice da primeira ocorrência parâmetro passado
        print(c.index(5))                                       #saída será 1
        print(c.index(5,2))                                     #usando o deslocamento a partir do índice 2 a saída será 3

        numeros = (2, 6, 9, 3)
        if 3 in numeros: #para não dar erro no método index tem que ser verificado antes se há o número está na tupla
            print(f'O valor 3 apareceu na {numeros.index(3) + 1}ª posição.')
        else:
            print('O número 3 não foi digitado em nenhuma posição.')


    Exemplo de sequência heterogênea - tipos diferentes
        pessoa = ('Rafael', 44, 'M', 91.2)

    Apagar uma variável
        del(pessoa)

    Exemplo de concatenação de valores em uma tupla

    numeros = ()
    print('Os valores sorteados foram: ', end=' ')
        for c in range(0, 5):
    n = randint(1, 10)
    #Concatenação: cria-se uma nova tupla que irá receber os novos Elm
    # A vírgula (n,) é crucial para que o Python trate 'n' como uma tupla de um único item.
    numeros += (n, )
    print(n, end=' ')

    print(f'\nO maior valor sorteado foi {max(numeros)}.')
    print(f'O menor valor sorteado foi {min(numeros}.')

2) Listas[]
    - Pode ser escrita como uma lista de valores separados por vírgula entre colchetes.
    - Pode conter itens de tipos diferentes.
    - Podem ser mutáveis.

    - Como declarar uma lista vazia
        lista = [] ou lista = list()

    lanche = ['hamburguer', 'suco', 'pizza', 'pudim']

    lanche[3] = 'picole'                                                              #mutável
    lanche = ['hamburguer', 'suco', 'pizza', 'picole']

    lanche.append('cookie')                                                           #adciona no final
    lanche = ['hamburguer', 'suco', 'pizza', 'picole', 'cookie']

    lanche.insert(0, 'cachorrro-quente')                                              #adciona na posição de índice zero
    lanche = ['cachorrro-quente', 'hamburguer', 'suco', 'pizza', 'picole', 'cookie']

    del lanche[3] or lanche.pop[3] or lanche.remove('pizza')                          #normalmente utilizado para elininar o último Elm
    lanche = ['cachorrro-quente', 'hamburguer', 'suco', 'picole', 'cookie']           #deletou pizza

    lanche.pop()                                                                      #deleta o último Elm
    lanche = ['cachorrro-quente', 'hamburguer', 'suco', 'picole']

    Para garantir que o item está na lista:
        if 'pizza' in lanche:
            lanche.remove('pizza')

    Criar uma lista com a função list com um range
        valores = list(range(4, 11))                    #vai criar uma lista chamada valores

    valores.sort()                                      #ordena os valores
    valores.sort(reverse=True)                          #ordena na ordem inversa

    len(valores)                                        #retorna a qtd de Elm


    lista = []
    lista.append(5)
    lista.append(9)
    lista.append(4)
    for item in lista:
        print(f'{item}...', end='')

    for indice, item in enumerate(lista):
        if indice == 0:
            print('\n')
        print(f'Na posição {indice} econtrei o valor {item}!')

    for i in range(0, 5):
        lista.append(int(input('Digite um valor: ')))
    print(lista)

    a = [2, 3, 4, 7]
    b = a

    print(f'Lista A: {a}')
    print(f'Lista B: {b}')
    b[2] = 8 #vai atribuir as duas listas
    print(f'\nLista A: {a}')
    print(f'Lista B: {b}')

    b = a[:] #copia todos valores de a e atribui a b
    b[2] = 9
    print(f'\nLista A: {a}')
    print(f'Lista B: {b}')

3) Listas Compostas

    - Copiar uma lista para outra
        dados = ['Pedro', 25]
        pessoas = list()
        - Copia o conteúdo da lista dados para a lista pessoas
        pessoas.append(dados[:])
        pessoas = [['Pedro', 25]]
        galera.append(['Maria', 19])
        galera.append(['João', 32])
        pessoas = [['Pedro', 25], ['Maria', 19], ['João', 32]]
        print(pessoas[0][0]) ->saída: Pedro
        print(pessoas[1][1]) ->saída: 19
        print(pessoas[2][0]) ->saída: João
        print(pessoas[1])    ->saída: ['Maria', 19]

        for p in pessoas:
            print(p)

        saída:
        ['Pedro', 25]
        ['Maria', 19]
        ['João', 32]

        for p in pessoas:
            print(f'{p[0]} tem {p[1]} anos de idade.')

        alunos = list()
        dados = list()
        totmai = totmen = 0
        for c in range(0, 3):
            dados.append(str(input('Nome: ')))
            dados.append(int(input('Idade: ')))
            alunos.append(dados[:])
            dados.clear()
        print(alunos)

        for aluno in alunos:
            if p[1] >= 21:
                print(f'{p[0]} é maior de idade')
                totmai += 1
            else:
                print(f'{p[0]} é menor de idade')
                totmen += 1
        print(f'Temos {totmai} maiores e {totmen} menores de idade.')

4) Dicionários
   => dicionarios {}
    dados = dict()
    dados = {}
    dados = {'nome': 'Pedro', 'idade':25}
    print(dados['nome'])                  #saída: Pedro
    print(dados['idade'])                 #saída: 25

    dados['sexo'] = 'M'
    dados = {'nome': 'Pedro', 'idade':25, 'sexo': 'M'}

    del dados['idade']
    dados = {'nome': 'Pedro', 'sexo': 'M'}

    print(dados.values())                #saída(VALORES): dict_values(['Pedro', 'M'])
    print(dados.keys())                  #saída(KEYS): dict_keys(['nome', 'sexo'])
    print(dados.items())                 #saída(VALORES E KEYS): dict_items([('nome', 'Pedro'), ('sexo', 'M')])

    for k, v in dados.items():
        print(f'O {k} é {v}')

    Pode ser criado uma lista de dicionários.
    locadora = [ {'título':'Star Wars', 'ano': 1977, 'diretor': 'George Lucas'},
                {'título':'Avengers', 'ano': 2012, 'diretor': 'Joss Whedon'},
                {'título':'Matrix', 'ano': 1999, 'diretor': 'Wachowski'}]
    print(locadora[0]['ano'])             #saída: 1977
    print(locadora[2]['título'])          #saída: Matrix


    estado = dict()
    brazil = list()
    for c in range(0, 3):
        estado['uf'] = str(input('Unidade Federativa: '))
        estado['sigla'] = str(input('Sigla: '))
        brazil.append(estado.copy())  #tem que usar o método copy para repetir sempre a primeira informação inserida
    print(brazil)

    for e in brazil:
        for k, v in e.items():
            print(f'O campo {k} tem valor {v}')

5) Funções
    def soma(a, b):
        print(f'A = {a} e B = {b}')
        soma = a + b
        print(f'A soma A + B = {soma}')

    def contador(*num):
        # (*) vai devolver uma tupla com os argumentos passados
        tam = len(num)
        print(f'Recebi os valores {num} e são ao todo {tam} números.')
    aplicação => contador(1, 4, 5), contador(4, 3)

    a) Interactive help
        Função interna do Python => help()
        Pode ser usada no console do Python ou no corpo do programa
        Ex: help(len)

        - Pode ser verificado a documentação relativa ao assunto
            print(input.__doc__)

    b) Docstrings
        def contador(i, f, p):
            '''
            -> Faz uma contagem e mostra na tela.
            :param i: início da contagem
            :param f: fim da contagem
            :param p: passo da contagem
            :return: sem retorno
            '''
            c = i
            while c <= f:
                print(f'{c} ', end='')
                c += p
            print('FIM!')

        help(contador) #retorna a docstrings que foi escrito entre aspas triplas na função
        contador(2, 10, 2)

    c) Parâmetros opcionais
        #Pode ser colocado os valores que desejar como opcional (ou seja, a = 0; b = 0 ; c= 0).
        def somar(a, b, c=0):
            '''
            -> Faz a soma de três valores e mostra o resultado na tela
            :param a: o primeiro valor
            :param b: o segundo valor
            :param c: o terceiro valor, que é opcional (c = 0)
            :return:
            '''
            s = a + b + c
            print(f'A soma vale {s}')

        somar(3, 2, 5)
        somar(8, 3)

    d) Escopo de variáveis
        Variáveis globais - definidas no programa principal e tem o mesmo valor em todo o programa
        Variáveis localis - definidas dentro de uma função e só existe nela

        Para definir uma variável global dentro de uma função, utiliza-se a palavra reservada 'global'
        def nomedafunçaõ():
            global a    #a é nome da variável que será global
            ....

    e) Retornando valores
        Utilizar a palavara reservada 'return'
        Exemplo:
        def multiplicar(a=0, b=0, c=0):
            m = a * b * c
            return m

6) Módulos e pacotes
    Você pode criar no projeto outros arquivo .py (módulos) com as funções
separadas que poderão ser importadas para o programa principal.

    Vantagens:
        Organização do código
        Facilita a manutenção
        Ocultação do códgio detalhado
        Reutilização em outros projetos

    Pacote é um conjunto de módulos separados por assuntos. Ex: pacote uteis com os
módulos: números, strings, datas, cores...
    Como importar:
        import uteis
        from uteis import datas
    Como criar um pacote: dentro de um projeto cria uma pasta com o nome do pacote,
pois toda pasta é considerada um pacote.
    Nesta pasta estará as pastas dos módulos com os arquivos __init__.py

7) Tratamento de Erros e Exceções
    Toda exceção é filha de uma classe maior EXCEPTION.
    O mesmo try pode ter vários excepts:
        except TypeError:
        except ValueError:
        except OSError:
        ...

    try:
        <bloco de instruções que tentará ser executado>
    except:
        <mensagem de erro>
    else:
        <bloco de instruções se tudo ocorrer certo>
    finally:
        <bloco de instruções que vai ser executado sempre>

    Ex 1:
    try:
    a = int(input('Numerador: '))
    b = int(input('Denominador: '))
    r = a / b
    except Exception as erro:
        print('Infelizmente tivemos um problema :(')
        print(f'Problema encotrado foi {erro.__class__}')

    else:
        print(f'O resultado é {r:.1f}.')
    finally:
        print('Volte Sempre! Muito obrigado!')

    Ex 2:
    try:
    a = int(input('Numerador: '))
    b = int(input('Denominador: '))
    r = a / b
    except (ValueError, TypeError):
        print('Tivemos um problema com os tipos de dado que você digitou.')
    except ZeroDivisionError:
        print('Não é possível dividir um número por zero.')
    except KeyboardInterrupt:
        print('O usuário preferiu não informar os dados.')
    except Exception as erro:
        print(f'O erro encontrado foi {erro.__class__}')
    else:
        print(f'O resultado é {r:.1f}.')
    finally:
        print('Volte Sempre! Muito obrigado!')






















































































































































































































































































































































































